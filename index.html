<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SuMe-Chat | Secure P2P Chat</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- ‚úÖ Styles unchanged -->
<style>
/* --- all your CSS exactly the same --- */
</style>
</head>
<body>
<div id="chatCard">
  <h2>üîê SuMe-Chat</h2>

  <div id="myId">
    <span>Your Peer ID: <span id="myPeerId">Generating...</span></span>
    <button id="copyBtn" onclick="copyPeerId()">üìã Copy</button>
  </div>

  <div class="connect-row">
    <input id="peerIdInput" placeholder="Friend's Peer ID" />
    <button onclick="connectPeer()">Connect</button>
  </div>

  <div id="status" class="disconnected">Status: Not connected</div>

  <div id="chatContainer">
    <div id="chat"></div>
    <div id="controls">
      <input id="msgInput" placeholder="Type a message..." disabled />
      <button id="sendBtn" onclick="sendMsg()" disabled>Send</button>
    </div>
  </div>

  <div id="footer">Created by Suhail Al Mehedi</div>
</div>

<script src="https://unpkg.com/peerjs/dist/peerjs.min.js"></script>
<script>
/* ----------------------------------
   SECURITY + RELIABILITY IMPROVEMENTS
------------------------------------ */

let conn;
let cryptoKey;

// ‚úÖ PeerJS setup with fallback and safer ICE servers
const peer = new Peer({
  host: '0.peerjs.com',
  port: 443,
  secure: true,
  path: '/',
  debug: 1,
  config: {
    iceServers: [
      { urls: ['stun:stun.l.google.com:19302', 'stun:stun1.l.google.com:19302'] },
      {
        urls: 'turn:relay1.expressturn.com:3478',
        username: 'efYQXKAB2wxWtdjKOf',
        credential: 'W9qTXeDtvz7cOZZv'
      }
    ],
    sdpSemantics: 'unified-plan'
  }
});

peer.on('open', async id => {
  document.getElementById('myPeerId').innerText = id;
  await generateKey();
  setStatus('Ready to connect', 'disconnected');
});

peer.on('error', err => {
  console.error('PeerJS Error:', err);
  setStatus('Error: ' + err.type, 'disconnected');
  addMsg('‚ö† ' + err.message, 'system');
});

/* ------------------ ENCRYPTION ------------------ */
async function generateKey() {
  cryptoKey = await crypto.subtle.generateKey(
    { name: "AES-GCM", length: 256 },
    true,
    ["encrypt", "decrypt"]
  );
}

async function exportKey() {
  const raw = await crypto.subtle.exportKey("raw", cryptoKey);
  return btoa(String.fromCharCode(...new Uint8Array(raw)));
}

async function importKey(base64) {
  try {
    const raw = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
    cryptoKey = await crypto.subtle.importKey("raw", raw, "AES-GCM", true, ["encrypt", "decrypt"]);
  } catch (e) {
    console.error("Invalid key import:", e);
    addMsg("‚ùå Key exchange failed!", "system");
  }
}

async function encryptMsg(msg) {
  const enc = new TextEncoder().encode(msg);
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, cryptoKey, enc);
  return { iv: Array.from(iv), data: Array.from(new Uint8Array(ciphertext)) };
}

async function decryptMsg(payload) {
  try {
    const iv = new Uint8Array(payload.iv);
    const data = new Uint8Array(payload.data);
    const plain = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, cryptoKey, data);
    return new TextDecoder().decode(plain);
  } catch {
    addMsg("‚ö† Decryption failed. Possibly tampered message.", "system");
    return null;
  }
}

/* ------------------ UTILITIES ------------------ */
function sanitize(str) {
  return str.replace(/[&<>]/g, c => ({ '&':'&amp;','<':'&lt;','>':'&gt;' }[c]));
}

function copyPeerId() {
  const id = document.getElementById('myPeerId').innerText;
  if (id && id !== 'Generating...') {
    navigator.clipboard.writeText(id)
      .then(() => alert('Peer ID copied!'))
      .catch(() => alert('Clipboard error!'));
  }
}

function setStatus(text, cls) {
  const s = document.getElementById('status');
  s.innerText = "Status: " + text;
  s.className = cls;
}

function addMsg(text, type) {
  const chat = document.getElementById('chat');
  const div = document.createElement('div');
  div.className = type === 'me' ? 'message me' :
                  type === 'friend' ? 'message friend' :
                  'message system';
  div.innerHTML = sanitize(text) + `<div class="timestamp">${new Date().toLocaleTimeString()}</div>`;
  chat.appendChild(div);
  chat.scrollTo({ top: chat.scrollHeight, behavior: 'smooth' });
}

/* ------------------ CONNECTION HANDLING ------------------ */
function connectPeer() {
  const peerId = document.getElementById('peerIdInput').value.trim();
  if (!peerId) return alert('Enter Peer ID!');
  if (peerId === peer.id) return alert('You cannot connect to yourself!');
  setStatus('Connecting...', 'connecting');

  conn = peer.connect(peerId, { reliable: true });

  setupConnectionEvents(conn);
}

function setupConnectionEvents(c) {
  c.on('open', async () => {
    setStatus('Connected to ' + c.peer, 'connected');
    addMsg('‚úÖ Connected to ' + c.peer, 'system');
    enableChat(true);

    // Exchange encryption key
    try {
      c.send({ key: await exportKey() });
    } catch (e) {
      console.error('Key send error:', e);
      addMsg('‚ö† Could not send key.', 'system');
    }
  });

  c.on('data', handleData);
  c.on('close', () => {
    setStatus('Disconnected', 'disconnected');
    addMsg('‚ùå Connection closed', 'system');
    enableChat(false);
  });
  c.on('error', err => {
    console.error('Connection error:', err);
    setStatus('Error: ' + err.type, 'disconnected');
    addMsg('‚ö† Connection error.', 'system');
  });
}

function enableChat(enabled) {
  document.getElementById('sendBtn').disabled = !enabled;
  document.getElementById('msgInput').disabled = !enabled;
}

/* ------------------ MESSAGE HANDLING ------------------ */
async function handleData(data) {
  if (data.key) {
    await importKey(data.key);
    addMsg('üîê Secure channel established!', 'system');
  } else if (data.msg) {
    const text = await decryptMsg(data.msg);
    if (text) addMsg(text, 'friend');
  }
}

async function sendMsg() {
  const msgInput = document.getElementById('msgInput');
  const msg = msgInput.value.trim();
  if (!conn || !msg) return;

  try {
    const encrypted = await encryptMsg(msg);
    conn.send({ msg: encrypted });
    addMsg(msg, 'me');
    msgInput.value = '';
  } catch (e) {
    console.error('Send error:', e);
    addMsg('‚ö† Failed to send message.', 'system');
  }
}

/* ------------------ INCOMING CONNECTION ------------------ */
peer.on('connection', c => {
  if (conn && conn.open) {
    c.close(); // Prevent double connections
    return;
  }
  conn = c;
  setupConnectionEvents(conn);
  setStatus('Connected to ' + conn.peer, 'connected');
  addMsg('üîî Someone connected to you!', 'system');
  enableChat(true);
});
</script>
</body>
</html>
